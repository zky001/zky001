<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://www.zky001.cn/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://avatars0.githubusercontent.com/u/16217370?v=3&amp;u=2144c8c49f4133187993121c83f24b1b35aebbd3&amp;s=140" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Markgolzh</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/zky001" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/kaiyuan-zhnag" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="/1134386961@qq.com" title="mail">mail</a>
					        
								<a class="facebook" target="_blank" href="https://www.facebook.com/profile.php?id=100006625267946" title="facebook">facebook</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Markgolzh</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="https://avatars0.githubusercontent.com/u/16217370?v=3&amp;u=2144c8c49f4133187993121c83f24b1b35aebbd3&amp;s=140" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Markgolzh</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/zky001" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/kaiyuan-zhnag" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="/1134386961@qq.com" title="mail">mail</a>
			        
						<a class="facebook" target="_blank" href="https://www.facebook.com/profile.php?id=100006625267946" title="facebook">facebook</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-16 The Linux Kernel--Configuring the Kernel Part 12" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/02/16 The Linux Kernel--Configuring the Kernel Part 12/" class="article-date">
  	<time datetime="2016-05-01T16:28:20.316Z" itemprop="datePublished">2016-05-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="戴文的Linux内核专题：16-配置内核-12"><a href="#戴文的Linux内核专题：16-配置内核-12" class="headerlink" title="戴文的Linux内核专题：16 配置内核 (12)"></a>戴文的Linux内核专题：16 配置内核 (12)</h1><p><img src="http://www.linux.org/attachments/slide-jpg.539/" alt=""></p>
<p>欢迎来享受Linux内核配置系列下一部分。如你所猜到的那样，内核支持大量不同的硬件、协议和特性。</p>
<p>下一组我们要讨论的特性是”EEPROM support”。电可擦除可编程只读存储器(Electrically Erasable Programmable Read-Only Memory)是一种掉电或者意外关闭后不会擦除内容的存储器。</p>
<p>内核支持在I2C卡上的EEPROM芯片包括FRAMs、ROMs和SRAMs (I2C EEPROMs / RAMs / ROMs 来自多数供货商)。FRAM(同样也称作FeRAM是一种使用铁电原理而不是电介质存储数据的随机访问存储芯片)。ROM芯片是只读(Read Only Memory)芯片。SRAM是静态而不是动态存储器就像DRAM。DRAN必须被刷新以保留数据而SRAM不需要刷新。然而，两者都会在电源关闭或者丢失时失去数据。</p>
<p>内核支持SPI总线的EEPROM(SPI EEPROMs from most vendors)。串行外设接口总线(Serial Peripheral Interface Bus (SPI))是一个缺乏错误检测的全双工总线系统。</p>
<p>老式的I2C EEPROM芯片需要一个除了上面I2C驱动之外的驱动(Old I2C EEPROM reader)。I2C总线用于嵌入式系统和电话，由于它用的是低速总线协议。</p>
<p>这个特性用来防止Maxim的可编程EEPROM变成只读模式(Maxim MAX6874/5 power supply supervisor)。特别地，这驱动提供对这个芯片的更好的电源管理。</p>
<p>这里还有一个驱动”EEPROM 93CX6 support”，”Microwire EEPROM 93XX46 support”和”ENE CB710/720 Flash memory card reader support”。</p>
<p>和其他内核特性一样，这里有一个对于EEPROM的调试特性(Enable driver debugging)。再说一次，为了更好的性能，禁用调试特性。</p>
<p>下面，我们有一个TI特性(Shared transport core driver)。这个驱动提供对于BT/FM和GPS芯片的传输协议。</p>
<p>下面的驱动支持I2C LIS3LV02Dx加速度计(STMicroeletronics LIS3LV02Dx three-axis digital accelerometer (I2C))。设备提供的数据存储在/sys/devices/platform/lis3lv02d。</p>
<p>下一步， Linux提供了下载固件到Altera的FPGA的模块(Altera FPGA firmware download module)。FPGA就是现场可编辑逻辑门阵列(field-programmable gate array)。它们是可编程集成电路。</p>
<p>Intel Management Engine Interface提供Intel芯片的安全和其他服务。</p>
<p>“ME Enabled Intel Chipsets”可以支持MEI。MEI是”Management Engine Interface”(管理引擎接口)。这个驱动支持有MEI服务的芯片组。</p>
<p>“VMware VMCI Driver”是一种用于客户机和宿主机中继通信的高速虚拟设备。VMCI代表的是”Virtual Machine Communication Interface”(虚拟机通信接口)。</p>
<p>下面， “ATA/ATAPI/MFM/RLL support”可以启用/禁用。MFM (Modified Frequency Modulation)是一种特殊的编码软驱位的方法。然而，这并不工作在所有的软驱上。MFM使用RLL(Run-Length Limited)编码制式。RLL通过有带宽限制的系统通信转换数据。ATAPI是先前提过的”ATA Packet Interface”，同时ATA也在讨论接口标准的时候讨论过。</p>
<p>现在我们将讨论SCSI支持。小型计算机接口(Small Computer System Interface (SCSI))是另外一种SATA的接口标准。USB和火线设备使用SCSI协议。</p>
<p>第一个SCSI设定关于”RAID Transport Class”。这允许RAID使用SCSI标准。</p>
<p>为了使用SCSI目标，启用这个特性(SCSI target support)。</p>
<p>如果系统会运行旧的Linux应用，系统可能需要”legacy /proc/scsi/ support”。这会在/proc/scsi创建SCSI文件。</p>
<p>为了支持SCSI磁盘，启用下一个特性(SCSI disk support)。这是一个通用驱动。</p>
<p>为了支持SCSI磁带，启用这个特性(SCSI tape support)。这是一个通用驱动。SCSI磁带驱动器在像磁带的磁性条上记录数据。</p>
<p>OnStream SCSI磁带需要这个驱动而不是前面提到SCSI通用驱动SCSI OnStream SC-x0 tape support)。</p>
<p>“对于SCSI CDROM support”，一些CD-ROM使用SCSI协议。</p>
<p>下面， 用户可以启用”Enable vendor-specific extensions (for SCSI CDROM)”。</p>
<p>这是一个对于大量不同SCSI设备的通用驱动(SCSI generic support)。这主要用于SCSI扫描仪和其他不被上面提到的SCSI驱动支持的设备或者那些之后会讨论的设备。</p>
<p>一些SCSI点唱机需要这个SCSI驱动(SCSI media changer support)。</p>
<p>Linux内核提供”SCSI Enclosure Support”。SCSI附件是一种管理电源和制冷SCSI设备同时提供不关于数据的服务的设备。</p>
<p>Linux内核应该设置为每个SCSI设备搜索全部的逻辑单元号(Logical Unit Numbers (LUN))(Probe all LUNs on each SCSI device)。LUN是SCSI地址。</p>
<p>这有额外的对于SCSI的错误报告(Verbose SCSI error reporting (kernel size +=12K))。这会明显地增加内核的大小。</p>
<p>这里还有一个SCSI日志系统(SCSI logging facility)。</p>
<p>为了增强你的系统，启用这个特性会允许SCSI在系统启动时就被探测到而不是先启用再探测(Asynchronous SCSI scanning)。大多数系统可以一次执行这两个任务，因此为什么允许这项? 对于那些连接了很多SCSI设备的硬件，这个会明显加快启动速度。</p>
<p>下面，”Parallel SCSI (SPI) Transport Attributes”(传统的并行SCSI)允许每个SCSI设备发送传输信息给sysfs。一些系统需要这个特性。</p>
<p>下面的特性和上面提到的一样，但是发送光纤通道设备的传输信息(FiberChannel Transport Attributes)(光纤通道接口)。光线通道设备使用SCSI。</p>
<p>下面用户可以启用/禁用”SCSI target support for FiberChannel Transport Attributes”(为光纤通道添加”target”模式驱动)。</p>
<p>iSCSI设备和SAS设备的传输数据可以导出到sysfs(iSCSI Transport Attributes)和SAS Transport Attributes)。SAS代表的的是”Serial Attached SCSI”(串行链接SCSI)。</p>
<p>下面，ATA支持被加入libsas(ATA support for libsas (requires libata))。注意配置工具提示需要libata。为了满足这个需求，启用ATA支持。更多情况下，配置工具已经或者将会会你这么做，但是请无论再检查一下。libsas和libata是相应的支持SAS和ATA的库。</p>
<p>下面的特性允许SAS接口接收SMP帧(Support for SMP interpretation for SAS hosts)。这加入了一个SMP解释器到libsas中。然而，这不会增加内核的尺寸。SMP帧允许所有在多CPU系统上的处理器访问SAS设备。</p>
<p>SRP可以发送传输的数据给sysfs(SRP Transport Attributes)。SRP代表SCSI RDMA协议(SCSI RDMA Protocol)。RDMA代表远程直接内存访问(Remote Direct Memory Access)。这意味着SRP是一个用来访问连接到另外一台计算机的SCSI设备的数据的协议。</p>
<p>下一步，用户可以启用”SCSI target support for SRP Transport”。</p>
<p>可以启用底层SCSI驱动(SCSI low-level drivers)。这提供了很多基础驱动。</p>
<p>在这之后，用户可以启用/禁用”PCMCIA SCSI adapter support”。这个适配器允许SCSI设备连接到PC卡上。</p>
<p>这里有一些驱动用于特殊的适配器- (Future Domain PCMCIA support)、(Qlogic PCMCIA support) 、(Symbios 53c500 PCMCIA support)。</p>
<p>多路径安装的设备需要这个特性(SCSI Device Handlers)。这用在每个节点都需要一个到SCSI存储单元的直接路径的集群中。</p>
<p>下一步，”OSD-Initiator library”(OSD启动库)可以启用。这是一个提供了补丁、OSD协议、和针对SCSI设备的T10协议的SCSI驱动。 OSD代表的是基于对象的存储设备(Object-based Storage Device);下一段会讨论得更多。</p>
<p>这个特性生成一个SCSI上层用于测试和管理/dev/osdx设备(OSD Upper Level driver)。exofs使用这个驱动用于挂载基于OSD的文件系统。OSD设备不像其他存储单元一样使用块的存储设备。相反地，OSD设备存储数据在称之为对象的容器里。exofs曾经称作OSDFS。</p>
<p>如果启用了它，OSD特性提供了调试工具(Compile All OSD modules with lots of DEBUG prints)。</p>
<p>如今，我们可以讨论串行ATA和并行ATA特性和驱动了。首先启用/禁用用于调试的第一个特性(Verbose ATA error reporting)。</p>
<p>下一步，用户应该对于ATA设备启用高级配置及电源接口特性(ATA ACPI Support)。这允许内核在SATA设备上更有效地管理电源使用。</p>
<p>内核包含了对于”SATA Zero Power Optical Disc Drive (ZPODD) support”的驱动。这会在不使用时关闭SATA光盘驱动器(SATA optical disc drives (ODD))。这节约了能源以及减少损耗。</p>
<p>贴士：即使你在编译一个高性能的内核，尝试启用所有的电源管理特性。则减少了电源消耗、操作开销、热量产生(热量会降低性能)，以及老化。</p>
<p>SATA端口复用器需要这个驱动(SATA Port Multiplier support)。端口复用器是一个拥有许多端口但是自己仅需插入一个端口的设备。举例来说，如果一个硬件有一个SATA口，但是还需要更多的口，在这个口上插入端口复用器。现在设备可以有许多SATA口了。</p>
<p>下一个驱动用于AHCI SATA(AHCI SATA support)。高级主机控制器接口(Advanced Host Controller Interface (AHCI))是一种SATA总线适配器的操作标准。</p>
<p>对于要在Soc硬件上支持AHCI SATA设备，必须启用这个驱动(Platform AHCI SATA support)。Soc代表片上系统(System-on-a-Chip)。</p>
<p>下面是一些特殊设备的驱动</p>
<ul>
<li>Initio 162x SATA support</li>
<li>ACard AHCI variant (ATP 8620)</li>
<li>Silicon Image 3124/3132 SATA support</li>
</ul>
<p>再说一次，等着下一篇精彩的文章。</p>
<hr>
<p>via: <a href="http://www.linux.org/threads/the-linux-kernel-configuring-the-kernel-part-12.4681/" target="_blank" rel="external">http://www.linux.org/threads/the-linux-kernel-configuring-the-kernel-part-12.4681/</a></p>
<p>译者：<a href="https://github.com/geekpi" target="_blank" rel="external">geekpi</a> 校对：<a href="https://github.com/wxy" target="_blank" rel="external">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="external">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="external">Linux中国</a> 荣誉推出</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-15 The Linux Kernel--Configuring the Kernel Part 11" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/02/15 The Linux Kernel--Configuring the Kernel Part 11/" class="article-date">
  	<time datetime="2016-05-01T16:28:20.312Z" itemprop="datePublished">2016-05-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="戴文的Linux内核专题：15-配置内核-11"><a href="#戴文的Linux内核专题：15-配置内核-11" class="headerlink" title="戴文的Linux内核专题：15 配置内核 (11)"></a>戴文的Linux内核专题：15 配置内核 (11)</h1><p><img src="http://www.linux.org/attachments/slide-jpg.530/" alt=""></p>
<p>准备好配置更多的驱动了么？还有很多要做。</p>
<p>Linux支持两种不同的康柏智能阵列控制器：(Compaq SMART2 support)和(Compaq Smart Array 5xxx support)。阵列控制器是将物理存储单元表现为逻辑单元的设备。这些控制可能同样实现了基于硬件的RAID。硬件和软件RIAD的不同是简单的。Linux管理并见到软件RIAD。Linux将硬件RAID视为另外的存储单元。这意味着Linux没有意识到设备就是RAID驱动器。硬件(阵列控制器)独立于内核管理着RAID系统。这对于系统的性能更好因为内核不必配置或者管理RAID。注意，不同的阵列控制器有不同的RAID能力。</p>
<p>上面提到的阵列控制器可以通过这个驱动访问SCSI磁带(SCSI tape drive support for Smart Array 5xxx)。SCSI磁带是使用SCSI协议的磁带机。</p>
<p>PCI RAID控制器Mylex DAC960、AcceleRAID和eXtremeRAID在这个驱动中支持(Mylex DAC960/DAC1100 PCI RAID Controller support)。PCI RAID控制器是一个连接到PCI卡的阵列控制器。RAID控制器是拥有RAID功能的阵列控制器。</p>
<p>带电源备份的MM5415内存芯片在这个驱动中支持(Micro Memory MM5415 Battery Backed RAM support)。带后备电源内存芯片允许数据在切断电源后继续保存在内存设备中。这有助于保护数据。不然，当电源断开后，当前的计算机会话就会丢失。</p>
<p>当启用这个特性后，可以将典型的文件(比如ISO文件)作为一个块设备并挂载它Loopback device support)。这对于从镜像文件中检索文件而不必把文件烧录到光盘或者解压出来。想像一下你从因特网上得到了一份包含了很多文件的ISO文件。如果你只需要包中的一个文件并且用户不希望烧写ISO到光盘上或者不想知道如何打开一个ISO文件。用户可以用挂载ISO来替代。</p>
<p>Linux内核在初始化阶段会创建一些回路设备，所以一些回环设备已经准备好并创建了(Number of loop devices to pre-create at init time)。当一个文件(像ISO)或者虚拟设备(就像虚拟磁盘驱动器[vhd])被作为回环设备挂载时会节约一些时间。这个设定允许开发者选择内核可以预<br>创建多少回环设备。</p>
<p>当”Cryptoloop Support”启用后就可以CryptoAPI创建密码。这个用于硬件驱动器加密。然而，并不是所有的文件系统都支持。</p>
<p>下面用户可以启用”DRBD Distributed Replicated Block Device support”(译注：Linux上的分布存储系统)。这个就像网络RAID1。这些设备拥有设备文件/dev/drbdx。这些设备通常被用于集群，这里集群中的每台计算机都有一个从主单元镜像过来的存储单元。这意味着每台计算机的硬盘是位于组中心计算机硬盘的镜像拷贝。集群是一组计算机扮演着一台大型强力单元的角色。然而，每个集群都有一台控制计算机称为主节点。余下的计算机是从节点。</p>
<p>DRBD支持用于测试IO错误处理的故障注射(DRBD fault injection)。记住，故障注射就是使设备/软件认为发生了一个错误，因此开发者可以测试硬件/软件如何处理错误</p>
<p>如果内核要成为网络块设备的客户端，那么启用这个特性(Network block device support)。第一个设备文件是/dev/nd0。网络块设备是通过网络访问的远程存储单元。</p>
<p>直接连接SSD到PCI或者PCIe需要这个驱动(NVM Express block device)。</p>
<p>用这个特性允许将单独的SCSI OSD(object-based storage,基于对象的存储)对象作为块设备(OSD object-as-blkdev support)。</p>
<p>下一个驱动是”Promise SATA SX8 support”。这个驱动用于Promise公司(Promise Technology Inc.)生产的SATA控制器。</p>
<p>Linux允许将一部分内存作为块设备(RAM block device support)。这通常见与完全运行于内存上的Linux的live发行版。Linux的live发行版会卸载光盘并接着加载到内存中，所以在尝试一个新的操作系统或者修复另一个系统时不会伤害到已安装的系统。</p>
<p>下一个选项允许用户输入”Default number of RAM disks”(默认RAM磁盘数量)。</p>
<p>“Default RAM disk size”(默认RAM磁盘大小)可以以KB设置大小。</p>
<p>内核可以支持在内存设备的XIP文件系统作为块设备(Support XIP filesystems on RAM block device)。这个特性会增大内核的大小。 XIP (eXecute In Place)文件系统是一个允许可执行文件在相同的文件系统上存储数据而不必像其他应用一样利用内存。在一个驻留在内存上的live版linux系统上运行可执行文件时需要这个文件系统。</p>
<p>下面，内核可以支持”Packet writing on CD/DVD media”。(CD/DVD刻录机支持.)</p>
<p>内核开发者可以设置最大活跃并发包数量(Free buffers for data gathering)。大的数字会以内存的消耗为代价加速写入性能。一个包会消耗大约64KB。</p>
<p>Linux内核可以使用可擦写光盘作为缓存空间(Enable write caching)。这个特性仍然是试验性质。</p>
<p>下面的特性允许通过以太网线缆使用ATA规范(ATA over Ethernet support)。</p>
<p>下面的驱动允许虚拟块设备创建为virtio(Virtio block driver)。virtio是IO虚拟化平台。</p>
<p>一些非常老的硬盘还要一个特殊的驱动(Very old hard disk (MFM/RLL/IDE) driver)。</p>
<p>这里有一个驱动用于先前提到的Rados设备(Rados block device (RBD))。</p>
<p>下面是一个特殊的设备驱动(IBM FlashSystem 70/80 PCIe SSD Device Driver)。</p>
<p>现在，我们可以进入杂项设备。第一个设定是启用/禁用电位器(Analog Devices Digital Potentiometers )。</p>
<p>如果电位器在I2C总线上，那么就启用这个(support I2C bus connection)。</p>
<p>如果电位器是连接到SPI总线，那么需要这个驱动(support SPI bus connection)。</p>
<p>注意:Linux内核支持很多传感器因为Linux内核经常用于天气设备和机器人。</p>
<p>这个驱动用于IBM RSA(Condor)服务处理器(Device driver for IBM RSA service processor)。</p>
<p>内核同样支持PCI Sensable PHANToM设备驱动(Sensable PHANToM (PCI))。</p>
<p>这个驱动指引不同来自并行追踪接口(Parallel Trace Interface (PTI))的追踪数据发往Intel Penwell PTI口 (Parallel Trace Interface for MIPI P1149.7 cJTAG standard)。这个被指领的数据用于调试目的。</p>
<p>一些带有IOC4芯片的SGI IO控制器需要这个驱动(SGI IOC4 Base IO support)。SGI IO是由SCI管理的输入/输出设备。IOC4芯片控制着许多由这些设备执行的任务。这是一个基础驱动。其他对这些设备的驱动依赖于这个驱动。</p>
<p>这里有很少的TI闪存媒体适配器驱动在Linux内核中，(TI Flash Media interface support) 和(TI Flash Media PCI74xx/PCI76xx host adapter support)。</p>
<p>这个驱动(“Integrated Circuits ICS932S401”)用于ICS932S401时钟控制芯片。</p>
<p>Atmel同步串行通信外设(Synchronized Serial Communication peripheral (SSC))有一个驱动在内核中(Device driver for Atmel SSC peripheral)。这个设备提供点对点的设备间的串行连接。</p>
<p>“Enclosure Services”特性支持硬盘托架。</p>
<p>这是对于CS5535/CS5536芯片的定时器驱动(CS5535/CS5536 Geode Multi-Function General Purpose Timer (MFGPT) support)。</p>
<p>这个驱动让应用可以与HP工业标准服务器中的iLO管理处理器通信(Channel interface driver for the HP iLO processor)。”iLO”代表的是”Integrity Integrated Lights-Out”.iLO允许远程服务器管理。</p>
<p>Linux内核支持ALS APDS9802光敏传感器(Medfield Avago APDS9802 ALS Sensor module)。一些其他支持的传感器包括：</p>
<ul>
<li>Intersil ISL29003 ambient light sensor</li>
<li>Intersil ISL29020 ambient light sensor</li>
<li>Taos TSL2550 ambient light sensor</li>
<li>ROHM BH1780GLI ambient light sensor</li>
<li>BH1770GLC / SFH7770 combined ALS - Proximity sensor</li>
<li>APDS990X combined als and proximity sensors</li>
</ul>
<p>注意：如果内核是为广泛的计算机编译的话，大多数驱动应该以模块形式加入。</p>
<p>Linux甚至可以使用”Honeywell HMC6352 compass”(一种电子罗盘)。</p>
<p>内核同样支持”Dallas DS1682 Total Elapsed Time Recorder with Alarm”。(一种运行时间记录仪)</p>
<p>16位的数模转换器通过这个驱动支持(Texas Instruments DAC7512)。</p>
<p>“VMware Balloon Driver”将客户机操作系统不需要的物理内存页交给需要那些需要的。</p>
<p>这里有两个不同的压力传感器(BMP085 digital pressure sensor on I2C) 和 (BMP085 digital pressure sensor on SPI)。</p>
<p>Intel输入/输出集线器(Intel Input/Output Hub (IOH))同样在内核中支持(Intel EG20T PCH/LAPIS Semicon IOH(ML7213/ML7223/ML7831) PHUB)。具体地说，这个是Intel Topcliff芯片组的PCH PHUB(Platform Controller Hub Packet Hub)</p>
<p>“FSA9480 USB Switch”是检测设备何时插入的检测器。</p>
<p>下一个选项允许比特流配置(Lattice ECP3 FPGA bitstream configuration via SPI)。</p>
<p>Silicon微控制器使用Silicon实验室C2端口，这需要一个特殊的驱动(Silicon Labs C2 port support)。</p>
<p>再说一次，继续留意下一篇文章因为我们还有更多的要做。</p>
<hr>
<p>via: <a href="http://www.linux.org/threads/the-linux-kernel-configuring-the-kernel-part-11.4640/" target="_blank" rel="external">http://www.linux.org/threads/the-linux-kernel-configuring-the-kernel-part-11.4640/</a></p>
<p>译者：<a href="https://github.com/geekpi" target="_blank" rel="external">geekpi</a> 校对：<a href="https://github.com/wxy" target="_blank" rel="external">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="external">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="external">Linux中国</a> 荣誉推出</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-14 The Linux Kernel--Configuring the Kernel Part 10" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/02/14 The Linux Kernel--Configuring the Kernel Part 10/" class="article-date">
  	<time datetime="2016-05-01T16:28:20.309Z" itemprop="datePublished">2016-05-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="戴文的Linux内核专题：14-配置内核-10"><a href="#戴文的Linux内核专题：14-配置内核-10" class="headerlink" title="戴文的Linux内核专题：14 配置内核 (10)"></a>戴文的Linux内核专题：14 配置内核 (10)</h1><p><img src="http://www.linux.org/attachments/slide-jpg.514/" alt=""></p>
<p>使用WiMAX协议的无线宽频设备可以启用这个(WiMAX Wireless Broadband support)。这个类型的无线连接通常需由服务供应商提供的连接服务才能工作(这与3G/4G的概念相同)。WiMAX代表”Worldwide Interoperability for Microwave Access”(微波存取全球互通)。WiMAX的目的是代替DSL。宽频指的是宽的带宽和大量信号的传输。</p>
<p>射频开关被用于许多Wifi和蓝牙卡中(RF switch subsystem support)。”RF”代表”Radio Frequency”。RF开关路由高频信号。</p>
<p>RF开关输入支持同样也在内核中支持(RF switch input support)。</p>
<p>内核可以控制并请求无线传输(Generic rfkill regulator driver)。启用这个生成一个设备文件(/dev/rfkill)。这个设备文件作为无线设备的接口。</p>
<p>Linux内核支持9P2000协议(Plan 9 Resource Sharing Support (9P2000))。这个网络协议有时称作Styx。Plan 9的窗口系统(Rio)的Styx和Linux的X11都使用Unix网络套接字。Linux系统可能使用Styx在Styx网络中。Plan 9和Linux可以在一个网络中使用Styx</p>
<p>“9P Virtio Transport”(9P 虚拟io传输)系统提供了在虚拟系统上客户机和主机分区间的传输。</p>
<p>内核同样支持RDMA传输(9P RDMA Transport (Experimental))。RDMA代表的是”Remote Direct Memory Access”(远程内存直接访问)。这个Plan9上访问远程计算机内存的协议。</p>
<p>9P系统与其他内核组件一样有调试特性(Debug information)。</p>
<p>“CAIF support”支持同样可以在内核中启用。CAIF代表” Communication CPU to Application CPU Interface”(通信CPU到应用CPU接口)。这是一个使用数据包的多路复用(MUX)协议并被用于ST-Ericsson(意法爱立信)调制解调器中。ST-Ericsson是开发这个协议的公司(是的，MeeGo和Android是Linux系统，并且我正在讨论Google的Andorid)。MUX协议就是多路复用(multiplexing)协议。多路复用在前面的文章中已经提到过。</p>
<p>下面，cephlib可以加入内核，它可以用于rados块设备(rbd)h和Ceph文件系统(Ceph核心库)(译注：Ceph是一种分布式文件系统)。cephlib是是Ceph的完整核心库。Ceph是存储平台。CephFs(Ceph文件系统)是运行在另外一个文件系统的顶部。通常，CephFs运行在EXT2、ZFS、XFS或者BTRFS上面。Rados设备是使用CephFs的块存储单元。</p>
<p>ceph的调试特性会损害内核性能，所以只在需要的时候启用(Include file:line in ceph debug output)。<br>当启用这个选项(Use in-kernel support for DNS lookup)，CONFIG_DNS_RESOLVER设施会执行DNS查询。</p>
<p>近场通信(Near Field Communication (NFC))设备在Linux内核中也被支持(NFC subsystem support)。</p>
<p>如果上面的特性被启用，那么NFC控制器接口(NFC Controller Interface (NCI))也应该启用(NCI protocol support)。这允许主机和NFC控制器相互通信。</p>
<p>NFC要处理HCI帧需要启用下面一个特性(NFC HCI implementation)。</p>
<p>一些HCI驱动需要一个SHDLC链路层(SHDLC link layer)(SHDLC link layer for HCI based NFC drivers)。SHDLC是检测完整性和管理HCI帧顺序的协议。</p>
<p>如果NFC特性启用了，那么通常也启用”NFC LLCP support”(就像上面那样)。</p>
<p>接下来有一些为特别的NFC设备的驱动。第一个是”NXP PN533 USB driver”。</p>
<p>下一个NFC驱动支持TI的BT/FM/GPS/NFC设备(Texas Instruments NFC WiLink driver)。</p>
<p>下面的是”NXP PN544 NFC driver”。</p>
<p>对于Inside Secure(译注：法国一家非接触半导体芯片厂商)生产的microread NFC芯片驱动同样在内核中支持(Inside Secure microread NFC driver)。</p>
<p>现在，我们将继续配置与网络无关的驱动。首先我们可以选择uevent帮助程序的路径(path to uevent helper)。如今许多计算机不在需要这个特性因为一个uevent帮助程序会在每次执行时fork一个进程处理。这回很快地消耗资源。</p>
<p>在启动时，内核会创建一个tmpfs/ramfs 文件系统(Maintain a devtmpfs filesystem to mount at /dev)。这个提供了完整的/dev目录系统。在这两个文件系统中(tmpfs和ramfs)，ramfs两者中最简单。”tmpfs”代表”temporary filesystem”(临时文件系统)，而”ramfs”代表”ram filesystem”(内存文件系统)。</p>
<p>下一个设置是devtmpfs文件系统的代码，它同样挂载在/dev下(Automount devtmpfs at /dev, after the kernel mounted the rootfs)。</p>
<p>下面的特性允许模块加载到用户空间(Userspace firmware loading support)。</p>
<p>为了”Include in-kernel firmware blobs in kernel binary”(译注：将固件编译进内核)(这会增加专有固件到内核中)，就启用这个特性。</p>
<p>一些二进制专有驱动需要在启动时使用。这个特性允许这类软件这么做(External firmware blobs to build into the kernel binary)。一些计算机有些引导设备需要只包含专有二进制文件的特殊固件。这个特性不启用，系统将无法引导。</p>
<p>启用”Fallback user-helper invocation for firmware loading”，允许user-helper(用户助手) (udev)作为内核加载固件驱动失败的后备手段加载固件。udev可以加载驻留在非标准路径的固件。</p>
<p>管理驱动的不跟内核如果被允许就可以生成调试信息(Driver Core verbose debug messages)。</p>
<p>下一步，如果启用这个特性(Managed device resources verbose debug messages)，devres.log文件就可以使用。这是一个用于设备资源的调试系统。</p>
<p>下面一个特性会通过netlink套接字生成一条用户空间和内核空间的连接(Connector - unified userspace &lt;-&gt; kernelspace linker)。这个套接字使用netlink协议。这是另外一个Linux系统即使在没有物理网络情况下仍需要网络特性的例子。</p>
<p>用户空间可以通过套接字得到进城时间的通知(Report process events to userspace)。一些报告事件包含了ID改变、fork、和退出状态。一些先前启用的内核特性可能需要这个。最好按配置工具建议的那样设置。</p>
<p>使用固态硬盘的系统需要MTD的支持(Memory Technology Device (MTD) support)。MTD设备是固态存储设备。典型的存储设备与固态硬盘(SSD)不同。用于磁盘单元的标准常规不适用于SSD(读、写、擦除)。</p>
<p>大多数会桌面电脑带有并口(一个有25个洞的连接器)，所以他们需要这个特性(Parallel port support)。并口在其他许多鲜为人知的应用中通常用于打印机和ZIP驱动器。并口有25针。</p>
<p>对IBM兼容计算机启用这个特性(PC-style hardware)。它们是不同类型的计算机。除了IBM计算机(通常运行Windows),还有苹果计算机。Linxu可以运行在几乎所有类型的计算机上。</p>
<p>Linux同样支持Multi-IO PCI卡(Multi-IO cards (parallel and serial))。Multi-IO PCI卡同时拥有并口和串口。串口每次发送或接收1位数据。</p>
<p>下一个特性允许内核”Use FIFO/DMA if available”。这用于特定的并口卡来加速打印。FIFO代表”First In, First Out”(先入先出)。DMA是先前提过的直接内存访问(Direct Memory Access)。</p>
<p>下面一个特性用于探测Super-IO卡(SuperIO chipset support)。这些探针会发信中断号、DMA通道和其他类型设备的地址/数量。Super-IO是一种集成IO控制器类型。</p>
<p>PCMCIA的并口支持可以启用(Support for PCMCIA management for PC-style ports)。</p>
<p>注意：对于许多特性来说，你最好按照配置工具的建议除非你有特别的理由不这么做。通常地，如果你是交叉编译或者编译一个通用内核，那么你应该熟悉你想要支持的并做出相应的选择。</p>
<p>在AX88796网络控制器的并口需要这个支持(AX88796 Parallel Port)。</p>
<p>“IEEE 1284 transfer modes”在并口上支持增强型并口(Enhanced Parallel Port (EPP))和增强功能口(Enhanced Capability Port (ECP))并支持打印机状态回读。状态回读是检索打印机的状态。</p>
<p>即插即用(“Plug and Play support” (PnP))应该启用。这允许用户在系统开机状态下插入设备并能马上使用它们。没有这个特性，用户不能使用USB设备、打印机或者其他没有执行特殊任务的设备。系统会自动管理复位(译注：原文是 “The system will manage the rest automatically”)。</p>
<p>下面，用户可以启用块设备(Block devices)。这是一个应该启用的特性，因为块设备很常见。</p>
<p>软驱也是可以启用的块设备(Normal floppy disk support)。</p>
<p>连接到并口的IDE设备也同样支持(Parallel port IDE device support)。一些外部CD-ROM设备也能通过并口连接。</p>
<p>外部IDE存储设备单元同样可以连接到并口(Parallel port IDE disks)。</p>
<p>连接到并口的ATA包接口(ATA Packet Interface (ATAPI)) CD-ROM需要这个驱动(Parallel port ATAPI CD-ROMs)。ATAPI是用于并行ATA(PATA)设备的ATA协议扩展。</p>
<p>还有一个ATAPI磁盘设备可以插到并口中(Parallel port ATAPI disks)。这个驱动会除了支持CD-ROM外还支持其他类型的磁盘。</p>
<p>内核同样支持通过并口连接ATAPI磁带设备(Parallel port ATAPI tapes)。</p>
<p>还有许多其他的ATAPI设备可以连接到并口中。结果就是，一个通用驱动被用于管理前面提到过的驱动不支持的设备(Parallel port generic ATAPI devices)。</p>
<p>连接到并口上的IDE设备需要一个特殊的协议用于通信。有很多这样的协议，其中一个是”ATEN EH-100 protocol”。</p>
<p>一个可选的用于并行IDE设备的协议是”MicroSolutions backpack (Series 5) protocol”。</p>
<p>这里仍有另外一个并口IDE设备协议(DataStor Commuter protocol)和另一个(DataStor EP-2000 protocol)还有(FIT TD-2000 protocol)。</p>
<p>再提一次，这里有另外一个协议，但是这个强烈建议用在更新的插在并口上的CD-ROM和PD/CD设备(FIT TD-3000 protocol)。</p>
<p>下面的协议主要用于SyQuest、Avatar、Imation和HP生产的并口设备(Shuttle EPAT/EPEZ protocol)。</p>
<p>Imation SuperDisks需要Shuttle EP1284芯片的支持(Support c7/c8 chips)。</p>
<p>一些其他的并行IDE协议可以启用，包括：</p>
<ul>
<li>Shuttle EPIA protocol</li>
<li>Freecom IQ ASIC-2 protocol - (用于Maxell Superdisks)</li>
<li>FreeCom power protocol</li>
<li>KingByte KBIC-951A/971A protocols</li>
<li>KT PHd protocol - (用于2.5英寸外置并口硬盘)</li>
<li>OnSpec 90c20 protocol</li>
<li>OnSpec 90c26 protocol</li>
</ul>
<p>注意：这些协议以及支持的插入并口的设备意味着这些都类似于热插拔设备,就像USB设备插入USB端口一样。USB和火线人仍旧是使用最流行的端口,因为它们的大小和速度。一个并口设备单元大于USB闪存因为并口大于USB端口。</p>
<p>下一步,我们有一个对于Micron PCIe的SSD驱动(Block Device Driver for Micron PCIe SSDs)。</p>
<p>你可能已经猜到了- 下面的文章会讨论更多的配置.</p>
<hr>
<p>via: <a href="http://www.linux.org/threads/the-linux-kernel-configuring-the-kernel-part-10.4613/" target="_blank" rel="external">http://www.linux.org/threads/the-linux-kernel-configuring-the-kernel-part-10.4613/</a></p>
<p>译者：<a href="https://github.com/geekpi" target="_blank" rel="external">geekpi</a> 校对：<a href="https://github.com/wxy" target="_blank" rel="external">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="external">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="external">Linux中国</a> 荣誉推出</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-10 The Linux Kernel--Configuring the Kernel Part 6" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/02/10 The Linux Kernel--Configuring the Kernel Part 6/" class="article-date">
  	<time datetime="2016-05-01T16:28:20.294Z" itemprop="datePublished">2016-05-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="戴文的Linux内核专题：10-配置内核-6"><a href="#戴文的Linux内核专题：10-配置内核-6" class="headerlink" title="戴文的Linux内核专题：10 配置内核(6)"></a>戴文的Linux内核专题：10 配置内核(6)</h1><p>欢迎来到下一篇关于内核配置文章！还有大量的选项需要配置。这篇文章将主要讨论PCI和ACPI。</p>
<p>这里我们可以启用由ACPI控制的扩展坞和可移动驱动器槽的支持(Dock)。记住，ACPI(Advanced Configuration and Power Management Interface)是一个电源管理系统。扩展坞是一种其他的设备通过额外的接口插入的设备。扩展坞可以容纳许多不同的端口和连接器。一个ACPI控制的扩展坞是指其电源管理是通过ACPI进行的。驱动器槽是一套可以增加硬盘的设备，这也可以由ACPI管理。</p>
<p>下面，我们允许ACPI用来管理空闲的CPU(Processor)。这会让处理器在空闲时进入ACPI C2或者C3状态。这可以节省电源并降低CPU芯片的温度。处理器只在100%没有占用时才进入空闲状态。没有程序必须请求一个特定时间的CPU资源。</p>
<p>CPU电源有四个状态 - C0、C1、C2和C3。C0是操作激活状态。C1(Halt)是一个不执行指令激活状态，但是可以立刻执行指令。C2(Stop-Clock)是一种断电状态。C3(Sleep)是一种比C2更彻底的断电状态。在C3状态中，现在缓存不再被同步或者管理，直到CPU离开这个状态。第五个状态称作C1E(Enhanced Halt State)，他拥有低功耗。</p>
<p>如果启用了IPMI驱动，那么ACPI可以访问BMC控制器(IPMI)。基板管理控制器(BMC)是一种管理软件和硬件间连接的微控制器。智能平台管理接口(IPMI)是一种框架，通过直接的硬件层面而不是登录shell或者操作系统层面来管理计算机。</p>
<p>ACPI v4.0进程聚合器允许内核应用一个CPU配置到所有系统中的处理器中(Processor Aggregator)。截止到ACPI v4.0，只有idle状态可以用这个方式配置。</p>
<p>接下来，可以启用ACPI热区(Thermal Zone)。多数硬件支持这个特性。这允许风扇的电源由ACPI管理。</p>
<p>如果启用这个选项，自定义DSDT可以链接到内核。在这个设置中，开发者必须在文件中包含完整的路径名。系统差异表(DSDT)是一个包含了系统支持的电源事件信息的文件。它不需要输入路径名，这些表存在于固件中。内核会帮你处理这些。这个主要的目的是用于如果开发者需要使用不同于设备内置的表时用到。</p>
<p>任意ACPI表都可以通过initrd来覆盖(ACPI tables override via initrd)。ACPI表是指示如何控制并与硬件交互的基础规则和指令。</p>
<p>像内核的其他部分一样，ACPI系统也可以生成调试信息(Debug Statements)。像其他调试特性一样，你或许希望禁用它并省下50KB。</p>
<p>启用下面的特性会为系统检测到的每个PCI插槽(PCI slot detection driver)创建文件(/sys/bus/pci/slots/)。一个PCI插槽是在PCI主板上的一个端口，它允许用户接上其他的PC设备。PCI是主板的一种类型。PCI是指组件互相通信的方式。有些应用程序可能需要这些文件。</p>
<p>电源管理定时器是另外一种电源管理系统(Power Management Timer Support)。这是许多系统追踪时间的方式。这个只需要很少的能源。处理器的空闲、电压/频率调节和节流都不会影响这个定时器。大量的系统需要使用这个特性。</p>
<p>下面，可以启用ACPI模块和容器设备驱动(Container and Module Devices)。这会启用处理器、内存和节点的热插拔支持。它需要NUMA系统。</p>
<p>下面的驱动提供对ACPI内存的热插拔支持(Memory Hotplug)。有些设备甚至启用这个驱动也不支持热插拔。如果驱动以模块形式加入，那么模块将会被acpi_memhotplug调用。</p>
<p>注意：对于内核某个特定的功能，硬件、BIOS和固件在必须支持时会有问题。有些系统的BIOS是不控制硬件的。这种类型的BIOS通常不会限制特性。如果内核确实有一个特定的功能，硬件必须有能力完成这样的任务。</p>
<p>智能电源管理驱动提供访问电池的状态和信息(Smart Battery System)。</p>
<p>下面，我们有一个”Hardware Error Device”驱动。设备通过SCI报告硬件错误。通常上，大多数的错误会是已纠正的错误。</p>
<p>下面的是ACPI调试特性(Allow ACPI methods to be inserted/replaced at run time)。这允许ACPI AML方式不通过重启系统管理。 AML代表的是ACPI机器语言(ACPI Machine Language)。AML代码可以通过请求重启来改变和测试。</p>
<p>APEI是ACPI的错误接口(ACPI Platform Error Interface (APEI))。APEI从芯片给操作系统报告错误。这个错误接口同样提供错误注射的能力。</p>
<p>当”SFI (Simple Firmware Interface) Support” 启用后，硬件固件可以发送消息给操作系统。固件与操作系统间的通信通过内存中的静态表。SFI-only的计算机的内核工作需要这个特性。</p>
<p>想要改变处理器的时钟速度和运行时，就启用这个特性(CPU Frequency scaling)。CPU频率调整意味着改变处理器的时钟速度。这个驱动可以用于降低时钟频率以节能。</p>
<p>下面是另外一个电源管理子系统(CPU idle PM support)。当处理器不在活跃状态时，它最好处在有效的空闲方式来减少电源消耗和减少CPU损耗。减少电源消耗同样可以降低内部元件的发热。</p>
<p>Linux内核提供了很多CPU空闲驱动。在多处理器系统上，一些用户可能有一个理由在每个CPU上使用不同的驱动(Support multiple cpuidle drivers)。启用这个驱动可以允许用户给每个处理器设置不同的驱动。</p>
<p>对于Intel处理器，内核有一个特别为管理这类CPU芯片空闲的驱动(Cpuidle Driver for Intel Processors)。</p>
<p>当内存芯片空闲时，这些同样可以处于低功耗状态(Intel chipset idle memory power saving driver)。这个驱动是特别支持IO AT的Intel设备的。</p>
<p>不同的计算机使用不同类型的主板(PCI support)。其中一种类型是PCI。这个驱动允许内核运行在PCI主板上。</p>
<p>下面，我们可以启用/禁用 “Support mmconfig PCI config space access”。</p>
<p>接下来，我们有一个选择启用/禁用主桥窗口驱动(Support mmconfig PCI config space access)。警告：这个驱动还没有完成(至少在3.9.4中是这样)。</p>
<p>像上面提到的主板，还有另一种类型的主板。写一个选项是提供”PCI Express (PCIe) support”的驱动。PCIe是一种改进并且更快速的PCI。</p>
<p>在这之后，下面的驱动应该被启用以支持PCIe主板上的热插拔(PCI Express Hotplug driver)。</p>
<p>接着，我们可以启用/禁用PCIe主板报错(Root Port Advanced Error Reporting)。这就是PCIe AER驱动。</p>
<p>下一个特性允许用户使用PCIe EREC(PCI Express ECRC settings control)覆盖BIOS和固件设置。下一个选项，这是对PCIe的错误注射(PCIe AER error injector support)。</p>
<p>下面的设置提供了操作系统控制PCI的活跃状态和时钟电源管理(PCI Express ASPM control)。通常上，固件会控制ASPM，但是这个特性允许操作系统采取控制。</p>
<p>如前面一样，像内核的许多组件一样，这里提供了ASPM的调试支持(Debug PCI Express ASPM)。</p>
<p>下面，在这个菜单选择”Default ASPM policy”。</p>
<p>在这选项之后，下一个是关于允许设备驱动启消息信号中断(Message Signaled Interrupts (MSI))。通常上最好允许设备给CPU发送中断。</p>
<p>为了在系统日志中加入大量的调试信息，启用”PCI Debugging”。</p>
<p>下一个选项允许PCI核心检测是否有必要启用PCI资源重分配(Enable PCI resource re-allocation detection)。</p>
<p>当在Linux上托管一个虚拟操作系统时，它有时可以用于为虚拟系统保留PCI设备(PCI Stub driver)。在系统虚拟化下，一个操作系统可能在另一个系统的内部或者并行。有时它们会竞争资源。可以为客户机保留设备可以减小竞争和增加性能。</p>
<p>下面的驱动允许超传输设备(hypertransport devices)使用中断(Interrupts on hypertransport devices)。HyperTransport是一种系统/协议总线用于处理器之间的高速通信。</p>
<p>下一个驱动用于PCI虚拟化，它允许虚拟设备间共享它们的物理资源(PCI IOV support)。</p>
<p>PCI页面请求接口(PRI)使在IOMMU(输入/输出内存管理单元)之后的PCI设备能够从页错误中恢复(PCI PRI support)。页错误不是一种错误；它指的是软件尝试访问不在物理内存上的数据的事件。</p>
<p>再次说明，你会在之后的文章中看到更多的需要配置Linux内核特性。</p>
<hr>
<p>via: <a href="http://www.linux.org/threads/the-linux-kernel-configuring-the-kernel-part-6.4457/" target="_blank" rel="external">http://www.linux.org/threads/the-linux-kernel-configuring-the-kernel-part-6.4457/</a></p>
<p>译者：<a href="https://github.com/geekpi" target="_blank" rel="external">geekpi</a> 校对：<a href="https://github.com/wxy" target="_blank" rel="external">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="external">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="external">Linux中国</a> 荣誉推出</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-04 The Linux Kernel--Security" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/02/04 The Linux Kernel--Security/" class="article-date">
  	<time datetime="2016-05-01T16:28:20.277Z" itemprop="datePublished">2016-05-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="戴文的Linux内核专题：04-安全"><a href="#戴文的Linux内核专题：04-安全" class="headerlink" title="戴文的Linux内核专题：04 安全"></a>戴文的Linux内核专题：04 安全</h1><p><img src="http://www.linux.org/attachments/slide-jpg.278/" alt=""></p>
<p>Linux内核是所有Linux系统的核心。如果有任何恶意代码控制或破害了内核的任何一部分，那么系统会严重受损，文件可能被删除或损坏，私人信息可能被盗等等。很明显，保持内核安全涉及到用户的最大利益。值得庆幸的是，由于Linux内核极其安全，Linux是一个非常安全的系统。在用户比例上，Linux病毒比Windows病毒更少，并且Linux用户比Windows用户个人更少感染病毒。(这就是为什么许多公司使用Linux来管理他们的服务器的一个原因。) 然而，我们仍然没有借口去忽视内核的安全。Linux有几个安全特性和程序，但本文只讨论Linux安全模块(LSM)及其它的内核安全特性。</p>
<p>AppArmor（应用盔甲）最初是由Immunix写的安全模块。自从2009年以来，Canonical维护着这些代码（Novell在Immunix之后，Canonical以前管理这些代码）。这个安全模块已经从2.6.36版本进入Linux主分支之中。AppArmor限制了程序的能力。AppArmor使用文件路径来跟踪程序限制。许多Linux管理员称AppArmor是最容易配置的安全模块。然而，而许多Linux用户觉得这个模块与其它的替代品相比很糟糕。</p>
<p>安全增强Linux(SELinux)是AppArmor的替代品，它最初由美国国家安全局开发（NSA）。SELinux自从2.6版本就进入内核主分支中。SELinux是限制修改内核和用户空间的工具。SELinux给可执行文件(主要是守护进程和服务端程序)最小特权去完成它们的任务。SELinux也可以用来控制用户权限。SELinux不像AppArmor那样使用文件路径，而SELinux在追踪权限时使用文件系统去标记可执行文件。因为SElinux本身使用文件系统管理可执行文件，所以SELinux不能像AppArmor那样对整个文件系统提供保护。</p>
<p>注意：守护进程是在后台运行的程序</p>
<p>注意：虽然在内核中有AppArmor、SELinux及其它安全模块，但只能有一个安全模块被激活。</p>
<p>Smack是安全模块的另一种选择。Smack从2.6.25起进入内核主分支。Smack应能比AppArmor更安全，但比SELinux更容易配置。</p>
<p>TOMOYO，是另外一个安全模块，在2.6.30进入内核主分支。TOMOYO可以提供安全防护，但是它的主要用途是分析系统安全缺陷。</p>
<p>AppArmor、SELinux、Smack和TOMYO组成了四个标准Linux安全模块。这些都通过使用强制访问控制(MAC ： mandatory access control)工作，这种访问控制是通过限制程序或者用户执行一些任务来实现的。安全模块还有某些形式的列表规定了它们可以做什么不可以做什么。</p>
<p>Yama在Linux内核中一个新安全模块。Yama还没有作为标准的安全模块，但是在将来他会成为第5个标准安全模块。Yama和其他安全模块一样使用相同的机制。</p>
<p>“grsecurity”是一系列Linux内核安全补丁的集合。多数补丁用于处理远程网络连接和缓冲区溢出的安全问题(以后讨论)。grsecurity中有一个叫PaX的有趣组件。PaX补丁允许内存里的代码使用最少的所需权限。例如，存储程序的内存段被标为不可写。想想看，为什么一个可执行的程序需要在内存中是可写的？通过这个补丁，恶意代码就不能修改目前正在执行的程序。缓冲区溢出是一种当程序由于bug或者恶意代码在内存上写入数据，并让它的内存边界超出到其他程序的内存页上的安全事件。当Pax被激活时，它会帮助阻止这些缓冲区溢出，因为程序没有写到其他内存页上的权限了。</p>
<p>Linux入侵检测系统(LIDS)是一个内核安全补丁，提供了强制访问控制(MAC)的特性。这个补丁就像扮演LSM模块的角色。</p>
<p>Systrace是一个减少和控制应用程序访问系统文件和系统调用的工具。系统调用是对内核的服务请求。比如，当一个文本编辑器写入一个文件到硬盘上时，程序将会发送一个系统请求让内核写入文件到硬盘中。</p>
<p>这些是在Linux安全系统中非常重要的组件。这些安全模块和补丁使内核免于受到恶意代码的攻击。没有这些特性，Linux系统将会变成一个不安全的操作系统。</p>
<hr>
<p>via: <a href="http://www.linux.org/threads/the-linux-kernel-security.4223/" target="_blank" rel="external">http://www.linux.org/threads/the-linux-kernel-security.4223/</a></p>
<p>译者：<a href="https://github.com/geekpi" target="_blank" rel="external">geekpi</a> 校对：<a href="https://github.com/wxy" target="_blank" rel="external">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="external">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="external">Linux中国</a> 荣誉推出</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/01/hello-world/" class="article-date">
  	<time datetime="2016-05-01T12:39:31.753Z" itemprop="datePublished">2016-05-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/01/hello-world/">Hello World</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Markgolzh
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>